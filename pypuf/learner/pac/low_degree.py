from itertools import combinations
import numpy as np
import time
from scipy.misc import comb as ncr
from pypuf.simulation.fourier_based.fourier_expansion import FourierExpansionSign, FourierCoefficient
from pypuf import tools


class LowDegreeAlgorithm:
    """
    Probabilistic algorithm to create a model of a Boolean function using a `training_set`. It approximates
    all Fourier coefficients of degree up to `degree`. If the training_set has size `get_training_set_size`
    and the function is epsilon/2-concentrated up to degree `degree` the algorithm returns a model that with
    probability 1-`delta` has accuracy 1-`epsilon`.
    :param training_set: The trainings set generated by tools.TrainingSet
    :param degree: The degree up to which the Fourier coefficients are approximated
    :param debug: If true, a progress message with ETA will be periodically printed to stdout
    """

    def __init__(self, training_set, degree, debug=False):
        self.training_set = training_set
        self.n = len(training_set.challenges[0])
        self.monomial_count = 0
        for k in range(degree + 1):
            self.monomial_count += ncr(self.n, k)
        self.degree = degree
        self.fourier_coefficients = []
        self.debug = debug

    @staticmethod
    def get_training_set_size(n, degree, epsilon, delta):
        monomial_count = 0
        for k in range(degree + 1):
            monomial_count += ncr(n, k)
        return int(4 * monomial_count * np.log(2 * monomial_count / delta) / epsilon)

    def learn(self):
        processed = 0
        last = 0
        start_time = time.time()
        for i in range(self.degree + 1):
            for s in self.low_degree_chi(i):
                self.fourier_coefficients.append(self.approx_fourier_coefficient(s))
                if not self.debug:
                    continue
                processed += 1
                current = int(processed / self.monomial_count * 100)
                if current > last:
                    current_time = time.time()
                    time_diff = current_time - start_time
                    duration_left = np.round((100 - current) * time_diff / current)
                    last = current
                    print('\r%s percent complete. Estimated time left: %s s  ' % (current, duration_left), end='')
        if self.debug:
            print()

        return FourierExpansionSign(self.fourier_coefficients)

    def approx_fourier_coefficient(self, s):
        """
        Approximate the Fourier coefficient of the function on subset `s`
        """
        return FourierCoefficient(s, tools.approx_fourier_coefficient(s, self.training_set))

    def low_degree_chi(self, degree):
        """
        Returns an iterator for the sets s (represented as {0,1}-arrays that represent monomials with degree exactly
        `degree`.
        """
        for indices in combinations(range(self.n), degree):
            yield np.array([1 if i in indices else 0 for i in range(self.n)])
